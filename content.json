{"meta":{"title":"Goblin' Blogs","subtitle":"A Java Engineer's technology blog with some daily sharing","description":"java technology blog sharing","author":"Goblin","url":"https://shitianshuai1111.github.io","root":"/"},"posts":[{"tags":[],"title":"记录","date":"2020/04/01","text":"1. 实体类的生日是Date类型, 直接返回前端, 前端难处理使用注解: @JsonFormat(shape=JsonFormat.Shape.STRING,pattern=\"yyyy-MM-dd\",timezone=\"GMT+8\") private Date birthday; 就可在传给前端时, 格式化日期为: { \"code\": 200, \"message\": \"操作成功\", \"data\": { \"birthday\": \"2020-04-08\", }} 2. 根据经纬度计算距离 已有用户的经纬度和商家的经纬度, 通过mysql sql语句根据距离排序查询出所有商家, 并将计算出的距离返回. SQL语句如下: 参数含义locationX-用户经度 locationY-用户纬度 lng-数据库中商家经度 lat-数据库中商家纬度 将距离计算出, 别名distance和其他数据一起返回 SELECT DISTINCT *,( round(6371392.89 * acos ( cos ( radians(#{locationY,jdbcType=DECIMAL}) ) * cos( radians( lat ) ) * cos( radians( lng ) - radians(#{locationX,jdbcType=DECIMAL}) ) + sin ( radians(#{locationY,jdbcType=DECIMAL}) ) * sin( radians( lat ) ) ),2 ) )AS distance FROM yd_shop ORDER BY distance 经测试 误差与百度地图计算距离控制在三十米之内. 3. 新增代码与mybatis逆向工程冲突问题 新增的代码会被mybatis逆向工程覆盖, 如果配置关闭覆盖, 那么以后对该表做改动的时候又要重写新增的部分. 解决: 将新增的内容, 写在新建Dao中, 令xml文件继承源mapper.xml, 这样新增内容时, 就不担心被覆盖了. SELECT DISTINCT *,( round(6371392.89 * acos ( cos ( radians(#{locationY,jdbcType=DECIMAL}) ) * cos( radians( lat ) ) * cos( radians( lng ) - radians(#{locationX,jdbcType=DECIMAL}) ) + sin ( radians(#{locationY,jdbcType=DECIMAL}) ) * sin( radians( lat ) ) ),2 ) )AS distance FROM yd_shop ORDER BY distance 4. 阿里云发送短信工具类: package com.macro.mall.portal.util;import com.aliyuncs.CommonRequest;import com.aliyuncs.CommonResponse;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.IAcsClient;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.http.MethodType;import com.aliyuncs.profile.DefaultProfile;import lombok.extern.slf4j.Slf4j;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * @description 阿里云短信工具类 * @author goblin * @date 2020-04-14 **/@Slf4jpublic class AliMessageUtils { public static final String CONFIG_FILE = \"rabbitmq-message.properties\"; public static String REGION_ID; public static String ACCESS_KEY_ID; public static String ACCESS_KEY_SECRET; public static String SIGN_NAME; public static String TEMPLATE_CODE; static { Properties prop = new Properties(); // 加载配置 try (InputStream is = QiniuUtils.class.getClassLoader().getResourceAsStream(\"rabbitmq-message.properties\")) { if (null == is) { log.error(\"[阿里云短信工具类-初始化]失败,请提供配置文件：{}\", CONFIG_FILE); } else { prop.load(is); } } catch (IOException e) { // 几乎不可能事件，直接转换为运行时异常继续上抛 throw new RuntimeException(e); } REGION_ID = prop.getProperty(\"region.id\", \"\"); ACCESS_KEY_ID = prop.getProperty(\"access.key.id\", \"\"); ACCESS_KEY_SECRET = prop.getProperty(\"access.key.secret\", \"\"); SIGN_NAME = prop.getProperty(\"sign.name\", \"\"); TEMPLATE_CODE = prop.getProperty(\"template.code\", \"\"); log.info(\"[阿里云工具类-初始化]完成\"); } //发送短信 public static void sendSMS(String phone, String code) { DefaultProfile profile = DefaultProfile.getProfile(REGION_ID, ACCESS_KEY_ID, ACCESS_KEY_SECRET); IAcsClient client = new DefaultAcsClient(profile); //拼接模板参数（验证码）value Json格式字符串 //您本次的验证码为：${code}，本验证码仅在5分钟内有效, 请勿告知他人, 如果不是您本人操作. 请忽略此信息. 欢迎您的加入! String codeSMS = \"{\\\"code\\\":\\\"\" + code + \"\\\"}\"; CommonRequest request = new CommonRequest(); request.setMethod(MethodType.POST); request.setDomain(\"dysmsapi.aliyuncs.com\"); request.setVersion(\"2017-05-25\"); request.setAction(\"SendSms\"); request.putQueryParameter(\"RegionId\", REGION_ID); request.putQueryParameter(\"PhoneNumbers\", phone); request.putQueryParameter(\"SignName\", SIGN_NAME); request.putQueryParameter(\"TemplateCode\", TEMPLATE_CODE); request.putQueryParameter(\"TemplateParam\", codeSMS); try { CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); } catch (ClientException e) { e.printStackTrace(); } }} 配置文件 rabbitmq-message.properties #地区region.id=cn-hangzhou#access.key.idaccess.key.id=access.key.id#access.key.secretaccess.key.secret=access.key.secret#签名sign.name=签名#短信模板template.code=短信模板","permalink":"https://shitianshuai1111.github.io/2020/04/01/%E8%AE%B0%E5%BD%95/","photos":[]},{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://shitianshuai1111.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"命令行","slug":"命令行","permalink":"https://shitianshuai1111.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}],"title":"Mac启动各项服务 终端命令","date":"2020/03/31","text":"Mac如何启动各项服务一. Redisredis-server 启动服务端redis-cli 客户端测试连接 二. RabbitMQsudo rabbitmq-server 三. MongoDBmongod -dbpath /usr/local/Cellar/mongodb-community/data/db","permalink":"https://shitianshuai1111.github.io/2020/03/31/Mac%E5%90%AF%E5%8A%A8%E5%90%84%E9%A1%B9%E6%9C%8D%E5%8A%A1/","photos":[]},{"tags":[{"name":"干货","slug":"干货","permalink":"https://shitianshuai1111.github.io/tags/%E5%B9%B2%E8%B4%A7/"},{"name":"笔记","slug":"笔记","permalink":"https://shitianshuai1111.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"title":"Docker怎么玩~","date":"2020/03/31","text":"一. Docker基础篇:Docker的三大要素: 镜像-只读的原本 类比java的类 容器-一个个在Docker中跑的程序(nginx, redis等) 类比java类创建出的实例 仓库-可以把打包好的镜像上传到DockerHub, 运维可以直接下载(国外的网站太慢, 用不到) 虚拟机和Docker的区别: CentOS/ Ubuntu基础镜像仅170MB 而虚拟机的镜像系统要4个G(同时模拟了硬件) docker(容器虚拟化技术) 虚拟机技术 操作系统 与宿主机共享, docker引擎调节 宿主机os上运行虚拟机os 储存大小 镜像小, 便于传输(Mb) 镜像大(G) 运行性能 几乎无额外性能损失 操作系统消耗额外cpu 移植性 轻便灵活 与虚拟化技术耦合 硬件亲和性 面向软件开发 面向运维 部署速度 秒级 分钟级(10s+) 开发/运维: DevOps 一次构建, 随处运行 Docker的架构图: 从远程Registry拉取到本地, 就是一个Images镜像, 这个镜像的实例就是一个Containers容器 镜像就是模板, 容器就是这个镜像的实例. 一个镜像可以创建很多容器. 可以把容器看成一个简易版的Linux环境, 和运行在其中的应用程序. 仓库是集中存放镜像文件的场所 Repository仓库和Registry仓库注册服务器是有区别的. 仓库注册服务器上往往存放着多个仓库, 每个仓库中又包含了多个镜像, 每个镜像有不同的标签(tag) 仓库又分为公开仓库和私有仓库. 两种形式, 世界最大公开仓库DockerHub, 国内的公开仓库 阿里云. Docker安装的官方文档: 安装就看他 https://docs.docker.com/install/linux/docker-ce/centos/ 阿里云镜像加速的配置文档: 配置阿里仓库就看他 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 专属加速地址 https://ld9eyi9w.mirror.aliyuncs.com Docker指令之helloworld: docker run hello-world先在本地找, hello-world的镜像 ->没有, 去远程拉取pulling 流程图: docker命令: 1. docker -version 版本信息2. docker info 详细信息3. docker --help 常用命令4. docker images 当前主机能运行的镜像模板 REPOSITORY: 镜像的仓库源 TAG: 版本 IMAGE ID: 镜像的唯一ID CREATED: 创建时间 SIZE : 大小5. docker search 去dockerhub查找(配置了镜像也是从dockerhub查询, 只是下载的时候去阿里云下载而已)6. docker pull 下载镜像7. docker rmi -f 镜像名 镜像名 镜像名... 删除镜像 清盘删除: docker rmi -f $(docker images -qa) $() 相当于 取出后面的docker images -qa的结果当做参数 tomcat为什么这么大呢? 8. docker run -it 470671670cac 9. docker ps 列出所有运行的容器10. exit 关闭容器并退出命令行 ctrl + p 再按 ctrl + q 不关闭容器, 先离开一会终端11. docker stop 停止容器 温柔关闭12. docker kill 直接杀死容器13. docker rm [-f] 容器号 删除容器 -f是强制删除(可删除正在运行的容器) docker rm -f $(docker ps -qa) 批量删除 或docker ps -qa | xargs docker rm linux命令, 管道符左边的结果当做参数传入右边的命令 docker run -d : 后台守护线程形式运行应用docker run -d centos /bin/sh -c \"while true;do echo hello zzyy;sleep 2; done\" 使用镜像centos以后台模式启动一个容器:$ docker run -d centos然后$ docker ps -a 进行查看, 会发现容器已经退出因为:Docker容器后台运行, 就必须有一个前台进程, 否则会自动退出这个是Docker的机制问题:比如nginx 我们配置启动服务只需要启动响应的service即可, 例如service nginx start但是这样 nginx为后台进程模式运行, 就会docker前台没有对应运行的应用.这样容器后台一启动, 就会立即自杀, 因为觉得自己没事做了.所以: 要将后台运行的程序以前台进程的形式运行 docker run -it centos /bin/bash 后面的 bin/bash的作用 (https://www.cnblogs.com/Guhongying/p/10894434.html) 首先，docker run -it centos 的意思是，为centos这个镜像创建一个容器， -i和-t这两个参数的作用是，为该docker创建一个伪终端，这样就可以进入到容器的交互模式？（也就是直接进入到容器里面）后面的/bin/bash的作用是表示载入容器后运行bash ,docker中必须要保持一个进程的运行，要不然整个容器启动后就会马上kill itself，这样当你使用docker ps 查看启动的容器时，就会发现你刚刚创建的那个容器并不在已启动的容器队列中。这个/bin/bash就表示启动容器后启动bash。 14. docker logs [参数] 容器id 查看日志 -f 跟随最新日志打印 -t 加入时间戳 --tail 显示最后多少条eg: docker logs -t -f --tail 3 7e0b062af691 15. docker top 容器id 查看容器内运行的进程16. docker inspect 容器id 查看容器的细节 比如: [ { \"Id\": \"7e0b062af6916144a33118a1\", \"Created\": \"2020-03-27T05:21:24.424453733Z\", \"Path\": \"/bin/sh\", \"Args\": [ \"-c\", \"while true;do echo hello zzyy;sleep 2; done\" ], \"State\": { \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 16750, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2020-03-27T05:21:24.799995316Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, \"Image\": \"sha256:...\", \"ResolvConfPath\": \"\", \"HostnamePath\": \"\", \"HostsPath\": \"\", \"LogPath\": \"\", \"Name\": \"/crazy_fermi\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"\", \"ExecIDs\": null, \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", \"PortBindings\": {}, \"RestartPolicy\": { \"Name\": \"no\", \"MaximumRetryCount\": 0 }, \"AutoRemove\": false, \"VolumeDriver\": \"\", \"VolumesFrom\": null, \"CapAdd\": null, \"CapDrop\": null, \"Capabilities\": null, \"Dns\": [], \"DnsOptions\": [], \"DnsSearch\": [], \"ExtraHosts\": null, \"GroupAdd\": null, \"IpcMode\": \"private\", \"Cgroup\": \"\", \"Links\": null, \"OomScoreAdj\": 0, \"PidMode\": \"\", \"Privileged\": false, \"PublishAllPorts\": false, \"ReadonlyRootfs\": false, \"SecurityOpt\": null, \"UTSMode\": \"\", \"UsernsMode\": \"\", \"ShmSize\": 67108864, \"Runtime\": \"runc\", \"ConsoleSize\": [ 0, 0 ], \"Isolation\": \"\", \"CpuShares\": 0, \"Memory\": 0, \"NanoCpus\": 0, \"CgroupParent\": \"\", \"BlkioWeight\": 0, \"BlkioWeightDevice\": [], \"BlkioDeviceReadBps\": null, \"BlkioDeviceWriteBps\": null, \"BlkioDeviceReadIOps\": null, \"BlkioDeviceWriteIOps\": null, \"CpuPeriod\": 0, \"CpuQuota\": 0, \"CpuRealtimePeriod\": 0, \"CpuRealtimeRuntime\": 0, \"CpusetCpus\": \"\", \"CpusetMems\": \"\", \"Devices\": [], \"DeviceCgroupRules\": null, \"DeviceRequests\": null, \"KernelMemory\": 0, \"KernelMemoryTCP\": 0, \"MemoryReservation\": 0, \"MemorySwap\": 0, \"MemorySwappiness\": null, \"OomKillDisable\": false, \"PidsLimit\": null, \"Ulimits\": null, \"CpuCount\": 0, \"CpuPercent\": 0, \"IOMaximumIOps\": 0, \"IOMaximumBandwidth\": 0, \"MaskedPaths\": [ \"/proc/asound\", \"/proc/acpi\", \"/proc/kcore\", \"/proc/keys\", \"/proc/latency_stats\", \"/proc/timer_list\", \"/proc/timer_stats\", \"/proc/sched_debug\", \"/proc/scsi\", \"/sys/firmware\" ], \"ReadonlyPaths\": [ \"/proc/bus\", \"/proc/fs\", \"/proc/irq\", \"/proc/sys\", \"/proc/sysrq-trigger\" ] }, \"GraphDriver\": { \"Data\": { \"LowerDir\": \"\", \"MergedDir\": \"\", \"UpperDir\": \"\", \"WorkDir\": \"\" }, \"Name\": \"overlay2\" }, \"Mounts\": [], \"Config\": { \"Hostname\": \"7e0b062af691\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": false, \"AttachStdout\": false, \"AttachStderr\": false, \"Tty\": false, \"OpenStdin\": false, \"StdinOnce\": false, \"Env\": [ \"PATH=/usr/local/\" ], \"Cmd\": [ \"/bin/sh\", \"-c\", \"while true;do ech\" ], \"Image\": \"centos\", \"Volumes\": null, \"WorkingDir\": \"\", \"Entrypoint\": null, \"OnBuild\": null, \"Labels\": { \"org.label-schema.build-date\": \"20200114\", \"org.label-schema.license\": \"GPLv2\", \"org.label-schema.name\": \"CentOS Base Image\", \"org.label-schema.schema-version\": \"1.0\", \"org.label-schema.vendor\": \"CentOS\", \"org.opencontainers.image.created\": \"2020-01-\", \"org.opencontainers.image.licenses\": \"GPL-2.0-only\", \"org.opencontainers.image.title\": \"CentOS Base Image\", \"org.opencontainers.image.vendor\": \"CentOS\" } }, \"NetworkSettings\": { \"Bridge\": \"\", \"SandboxID\": \"3459bdd5aa27c479a87\", \"HairpinMode\": false, \"LinkLocalIPv6Address\": \"\", \"LinkLocalIPv6PrefixLen\": 0, \"Ports\": {}, \"SandboxKey\": \"/var/run/docker/netns/3459bdd5aa27\", \"SecondaryIPAddresses\": null, \"SecondaryIPv6Addresses\": null, \"EndpointID\": \"e519bb72809ee6f974029\", \"Gateway\": \"172.18.0.1\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"IPAddress\": \"172.18.0.2\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"MacAddress\": \"02:42:ac:12:00:02\", \"Networks\": { \"bridge\": { \"IPAMConfig\": null, \"Links\": null, \"Aliases\": null, \"NetworkID\": \"126cf7e01e7d170ed\", \"EndpointID\": \"e519bb728\", \"Gateway\": \"172.18.0.1\", \"IPAddress\": \"172.18.0.2\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"MacAddress\": \"02:42:ac:12:00:02\", \"DriverOpts\": null } } } }] 17. docker attach 容器id 进入正在运行的容器并以命令行进行交互 直接进入容器启动命令的终端, 不做任何事 docker exec -it 容器id [/bin/bash ...] 在容器外执行, 既可以进去干, 还可以打开新进程(直接操作 隔山打牛的效果) 18. docker cp 容器id:容器内路径 目的主机路径 拷贝容器内文件到主机上 二. Docker高级篇 Docker镜像是什么: 轻量级的可执行的独立软件包, 用来打包软件运行环境和基于运行环境开发的软件, 它包含某个软件所需的所有内容, 包括代码, 运行时库, 环境变量, 和配置文件 UnionFS联合文件系统: 分层的轻量级高性能的文件系统. Docker镜像加载原理: docker镜像实际上由一层层的文件系统组成, bootfs: 主要包含bootloader和kernel, bootloader主要是引导加载kernel, linux刚启动时会加载bootfs文件系统, 在docker镜像的最底层是bootfs, 当boot加载完成后整个内核就都在内存中了, 此时内存的使用权已由bootfs转交给内核, 此时系统也会卸载bootfs rootfs: 在bootfs上, 包含的就是典型linux系统中的/dev, /proc, /bin等标准目录和文档, rootfs就是不同操作系统的发行版, 比如ubuntu centos等. tomcat 比centos还大的原因 docker采用分层镜像的原因: 共享资源 多个镜像都从相同的base镜像构建而来, 这样每个镜像的每一层都可被共享. docker的镜像都是只读的, 当容器启动时, 一个新的可写层被加载到 镜像的顶部, 这一层 通常被成为容器层, 容器层之下的都叫镜像层. docker 的commit 我们对一个源镜像, 进行了自定义的修改和配置后, 得到了我们专属的容器, 那么怎么把这个容器分享给他人, 使得他人启动这个容器和我们启动这个容器达到一样的效果呢? 这里就可以用commit命令. docker commit -a=\"goblin\" -m=\"my images\" 78sd7f8 mytomcat:v1.0 -a: author 作者 -m: 容器信息 要制作镜像的容器id 新镜像的名字:Tag(版本) docker容器数据卷: 当我们关闭容器后, 容器内的数据就没了, 那么我们关闭容器时, 需要对容器内产生的数据进行持久化. 这个要持久的数据就是数据卷. k将运用与运行的环境打包形成容器运行, 运行可以伴随着容器, 但是我们对数据的要求希望是持久化的 容器之间希望有可能共享数据 Docker容器产生数据, 如果不通过docker commit生成新的镜像, 使得数据作为镜像一部分保存下来, 那么当容器删除后, 数据也就没了. 为了能保存数据在docker中, 我们使用卷 目的就是: 持久化和数据共享 @1: 可以使用命令行 1. 在容器上建立文件夹挂载到主机上, 二者实时共享, 均可读写docker run -it -v /myDataVolumn:/dataVolumnContainer 镜像名2. 将容器上的文件夹/dataVolumnContainer(绝对路径)挂载到主机的/myDataVolumn, 容器只读: 容器只能查看主机传给他的文件, 自己不能写操作docker run -it -v /myDataVolumn:/dataVolumnContainer:ro 镜像名 (readonly) @2. 通过dockerfile dockerfile是对镜像 源码级 的描述,","permalink":"https://shitianshuai1111.github.io/2020/03/31/Docker%E7%9A%84%E7%94%A8%E6%B3%95/","photos":[]},{"tags":[],"title":"Hello World","date":"2020/03/31","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","permalink":"https://shitianshuai1111.github.io/2020/03/31/hello-world/","photos":[]},{"tags":[],"title":"Hexo Blog的搭建","date":"2020/03/29","text":"Hexo Blog的搭建一. 前期准备 git nodejs hexo 二. 创建流程 初始化hexo hexo init blogcd blog npm install 生成blog hexo ghexo server此时可以在localhost:4000看到 helloworld","permalink":"https://shitianshuai1111.github.io/2020/03/29/Hexo%20Blog%E7%9A%84%E6%90%AD%E5%BB%BA/","photos":[]},{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://shitianshuai1111.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"业务","slug":"业务","permalink":"https://shitianshuai1111.github.io/tags/%E4%B8%9A%E5%8A%A1/"}],"title":"Elasticsearch实现搜索","date":"2017/05/22","text":"Elasticsearch一. 目录结构mall项目的搜索模块: 目录结构 mall-search ​ |- src ​ |- main ​ |- java ​ |- com.mall.search ​ |- config ​ - MyBatisConfig ​ - Swagger2Config ​ |- controller ​ - EsProductController ​ |- dao ​ - EsProductDao ​ |- domain ​ - EsProduct ​ - EsProductAttributeValue ​ - EsProductRelatedInfo ​ |- repository ​ - EsProductRepository ​ |- service ​ |- impl ​ - EsProductServiceImpl ​ - EsProductService ​ - MallSearchApplication ​ |- resources ​ |- dao ​ |- EsProductDao.xml ​ - application.yml ​ - application-dev.yml ​ - application-prod.yml ​ - pom.xml 1.1 pom依赖 com.macro.mall mall-mbg org.springframework.boot spring-boot-starter-data-elasticsearch 1.2 controller接口/esProduct /importAll 导入所有数据库中商品到ES /delete/{id} 根据id删除商品 /delete/batch 根据id批量删除商品 /create/{id} 根据id创建商品 /search/simple 简单搜索 /search 综合搜索、筛选、排序 /recommend/{id} 根据商品id推荐商品 /search/relate 获取搜索的相关品牌、分类及筛选属性 二. 导入ES2.1 接口@ApiOperation(value = \"导入所有数据库中商品到ES\")@RequestMapping(value = \"/importAll\", method = RequestMethod.POST)@ResponseBodypublic CommonResult importAllList() { int count = esProductService.importAll(); return CommonResult.success(count);} importAll方法: @Overridepublic int importAll() { List esProductList = productDao.getAllEsProductList(null); Iterable esProductIterable = productRepository.saveAll(esProductList); Iterator iterator = esProductIterable.iterator(); int result = 0; while (iterator.hasNext()) { result++; iterator.next(); } return result;} select p.id id, p.product_sn productSn, p.brand_id brandId, p.brand_name brandName, p.product_category_id productCategoryId, p.product_category_name productCategoryName, p.pic pic, p.name name, p.sub_title subTitle, p.price price, p.sale sale, p.new_status newStatus, p.recommand_status recommandStatus, p.stock stock, p.promotion_type promotionType, p.keywords keywords, p.sort sort, pav.id attr_id, pav.value attr_value, pav.product_attribute_id attr_product_attribute_id, pa.type attr_type, pa.name attr_name from pms_product p left join pms_product_attribute_value pav on p.id = pav.product_id left join pms_product_attribute pa on pav.product_attribute_id= pa.id where delete_status = 0 and publish_status = 1 and p.id=#{id}","permalink":"https://shitianshuai1111.github.io/2017/05/22/Elasticsearch/","photos":[]},{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://shitianshuai1111.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"业务","slug":"业务","permalink":"https://shitianshuai1111.github.io/tags/%E4%B8%9A%E5%8A%A1/"}],"title":"图片上传策略之OSS","date":"2017/03/31","text":"方式一:一. OSSOss对象存储的优势体现在: 本张图片就存放于七牛云上 二. 需求现在, 用户可以提交意见反馈给后台, 反馈的内容同时可携带多张图片. 我们不想在数据库中直接保存图片的base64格式的字符, 因为如果图片很大, 那么数据库负担很重. 所以我们使用oss对象存储服务 三. 实现实现的流程为 1. 输入表单用户输入完表单, 选择好了要上传的图片, 点击 提交反馈 发送请求 2. 前端发送图片上传的请求该请求需设置请求头Content-Type: multipart/form-data; 请求体为form-data的file类型, 同时可以选择多张要上传的图片 3. 同时, 后端Controller接收请求package com.macro.mall.portal.controller;import com.macro.mall.common.api.CommonResult;import com.macro.mall.portal.domain.ImagesFile;import com.macro.mall.portal.util.QiniuUtils;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.UUID;/** * 图片上传Controller * Created by goblin. */@Controller@Api(tags = \"UploadFileController\", description = \"图片上传\")@RequestMapping(\"/upload\")public class UploadFileController { /** * 上传图片 * @param multipartFiles * @return */ @ApiOperation(\"上传图片\") @RequestMapping(value = \"/images\", method = RequestMethod.POST) @ResponseBody public CommonResult upload(@RequestParam(\"imgFile\") MultipartFile[] multipartFiles) { ArrayList imgFile = new ArrayList(); for (MultipartFile multipartFile : multipartFiles) { ImagesFile imagesFile = new ImagesFile(); //原始文件名 String originalFileName = multipartFile.getOriginalFilename(); imagesFile.setImageName(originalFileName); //使用UUID构造不重复的文件名 String fileName = UUID.randomUUID().toString().replace(\"-\", \"\") + \".\" + getPicSuffix(originalFileName); //获取输入流并上传 try (InputStream is = multipartFile.getInputStream()) { QiniuUtils.upload2Qiniu(is, fileName); } catch (RuntimeException| IOException e) { CommonResult.failed(); } //构造返回值 String pic = QiniuUtils.QINIU_IMG_URL_PRE + fileName; imagesFile.setImageUrl(pic); imgFile.add(imagesFile); } return CommonResult.success(imgFile); } public static String getPicSuffix(String imgPath){ if (imgPath == null || imgPath.indexOf(\".\") == -1){ return \"\"; //如果图片地址为null或者地址中没有\".\"就返回\"\" } return imgPath.substring(imgPath.lastIndexOf(\".\") + 1). trim().toLowerCase(); }} 值得注意的是, 这里需要用注解@RequestParam(“参数名”) MultipartFile[] 来接收多张图片 multipartFile.getOriginalFilename();可以用来获取上传文件的名字以及后缀. 这里用到了七牛云上传工具类: package com.macro.mall.portal.util;import com.qiniu.common.QiniuException;import com.qiniu.http.Response;import com.qiniu.storage.BucketManager;import com.qiniu.storage.Configuration;import com.qiniu.storage.Region;import com.qiniu.storage.UploadManager;import com.qiniu.util.Auth;import lombok.extern.slf4j.Slf4j;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * @author zhangmeng * @description 七牛云工具类 * @date 2019/9/26 **/@Slf4jpublic class QiniuUtils { public static final String CONFIG_FILE = \"qiniu-config.properties\"; public static String ACCESS_KEY; public static String SECRET_KEY; public static String QINIU_IMG_URL_PRE; public static String BUCKET; static { Properties prop = new Properties(); // 加载配置 try(InputStream is = QiniuUtils.class.getClassLoader().getResourceAsStream(\"qiniu-config.properties\")) { if(null == is){ log.error(\"[七牛云工具类-初始化]失败,请提供配置文件：{}\",CONFIG_FILE); }else { prop.load(is); } } catch (IOException e) { // 几乎不可能事件，直接转换为运行时异常继续上抛 throw new RuntimeException(e); } ACCESS_KEY = prop.getProperty(\"access.key\", \"\"); SECRET_KEY = prop.getProperty(\"secret.key\", \"\"); QINIU_IMG_URL_PRE = prop.getProperty(\"img.url.prefix\", \"\"); BUCKET = prop.getProperty(\"bucket\", \"\"); log.info(\"[七牛云工具类-初始化]完成\"); } /** * 上传到七牛云 * * @param is 上传内容的输入流 * @param uploadFileName */ public static void upload2Qiniu(InputStream is, String uploadFileName) throws QiniuException { //构造一个带指定Zone对象的配置类 Configuration cfg = new Configuration(Region.autoRegion()); //...其他参数参考类注释 UploadManager uploadManager = new UploadManager(cfg); //默认不指定key的情况下，以文件内容的hash值作为文件名 String key = uploadFileName; Auth auth = Auth.create(ACCESS_KEY, SECRET_KEY); String upToken = auth.uploadToken(BUCKET); try { Response response = uploadManager.put(is, key, upToken, null, null); //解析上传成功的结果 log.info(response.bodyString()); // 访问路径 log.info(\"{}/{}\", QINIU_IMG_URL_PRE, uploadFileName); } catch (QiniuException ex) { Response r = ex.response; log.error(r.toString()); try { log.error(r.bodyString()); } catch (QiniuException ex2) { //ignore log.error(\"\", ex2); } throw ex; } } public static void deleteFileFromQiniu(String fileName) throws QiniuException { //构造一个带指定Zone对象的配置类 Configuration cfg = new Configuration(Region.autoRegion()); String key = fileName; Auth auth = Auth.create(ACCESS_KEY, SECRET_KEY); BucketManager bucketManager = new BucketManager(auth, cfg); try { bucketManager.delete(BUCKET, key); } catch (QiniuException ex) { //如果遇到异常，说明删除失败 log.error(\"code:{}\", ex.code()); log.error(ex.response.toString()); throw ex; } }} 配置文件qiniu-config.properties在resource文件夹下 img.url.prefix=专属外链access.key=七牛云的AKsecret.key=七牛云的SKbucket=要上传到桶的名字 4. 前端收到结果{ \"code\": 200, \"message\": \"操作成功\", \"data\": [ { \"imageName\": \"timg (1).jpeg\", \"imageUrl\": \"http://q850xek50.bkt.clouddn.com/6ce55d289d8f499783d86771bbf2a074.jpeg\" }, { \"imageName\": \"timg (2).jpeg\", \"imageUrl\": \"http://q850xek50.bkt.clouddn.com/3deb81d57fa643c5ac9948d6ca72e59e.jpeg\" }, { \"imageName\": \"timg.jpeg\", \"imageUrl\": \"http://q850xek50.bkt.clouddn.com/327fa1b7964346588bdec1b28154e619.jpeg\" } ]} 5. 再次发送请求此时, 请求体中带着反馈的内容和图片的url等内容, 交由后端保存到数据库中. { \"feedback\": \" \", \"questionType\": \" \", \"images\": \" \" ...} 方式二:前端直接向阿里云OSS发送上传图片请求 Controller: package com.macro.mall.controller;import com.macro.mall.common.api.CommonResult;import com.macro.mall.dto.OssCallbackResult;import com.macro.mall.dto.OssPolicyResult;import com.macro.mall.service.impl.OssServiceImpl;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletRequest;/** * Oss相关操作接口 * Created by macro on 2018/4/26. */@Controller@Api(tags = \"OssController\", description = \"Oss管理\")@RequestMapping(\"/aliyun/oss\")@CrossOriginpublic class OssController { @Autowired private OssServiceImpl ossService; @ApiOperation(value = \"oss上传签名生成\") @RequestMapping(value = \"/policy\", method = RequestMethod.GET) @ResponseBody public CommonResult policy() { OssPolicyResult result = ossService.policy(); return CommonResult.success(result); } @ApiOperation(value = \"oss上传成功回调\") @RequestMapping(value = \"callback\", method = RequestMethod.POST) @ResponseBody public CommonResult callback(HttpServletRequest request) { OssCallbackResult ossCallbackResult = ossService.callback(request); return CommonResult.success(ossCallbackResult); }} OssServiceImpl: 前端请求后台生成 许可 /** * 签名生成 */@Overridepublic OssPolicyResult policy() { OssPolicyResult result = new OssPolicyResult(); // 存储目录 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMdd\"); String dir = ALIYUN_OSS_DIR_PREFIX + sdf.format(new Date()); // 签名有效期 long expireEndTime = System.currentTimeMillis() + ALIYUN_OSS_EXPIRE * 1000; Date expiration = new Date(expireEndTime); // 文件大小 long maxSize = ALIYUN_OSS_MAX_SIZE * 1024 * 1024; // 回调 OssCallbackParam callback = new OssCallbackParam(); callback.setCallbackUrl(ALIYUN_OSS_CALLBACK); callback.setCallbackBody(\"filename=${object}&size=${size}&mimeType=${mimeType}&height=${imageInfo.height}&width=${imageInfo.width}\"); callback.setCallbackBodyType(\"application/x-www-form-urlencoded\"); // 提交节点 String action = \"http://\" + ALIYUN_OSS_BUCKET_NAME + \".\" + ALIYUN_OSS_ENDPOINT; try { PolicyConditions policyConds = new PolicyConditions(); policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, maxSize); policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir); String postPolicy = ossClient.generatePostPolicy(expiration, policyConds); byte[] binaryData = postPolicy.getBytes(\"utf-8\"); String policy = BinaryUtil.toBase64String(binaryData); String signature = ossClient.calculatePostSignature(postPolicy); String callbackData = BinaryUtil.toBase64String(JSONUtil.parse(callback).toString().getBytes(\"utf-8\")); // 返回结果 result.setAccessKeyId(ossClient.getCredentialsProvider().getCredentials().getAccessKeyId()); result.setPolicy(policy); result.setSignature(signature); result.setDir(dir); result.setCallback(callbackData); result.setHost(action); } catch (Exception e) { LOGGER.error(\"签名生成失败\", e); } return result;} 配置文件: aliyun: oss: endpoint: # oss对外服务的访问域名 accessKeyId: # 访问身份验证中用到用户标识 accessKeySecret: # 用户用于加密签名字符串和oss用来验证签名字符串的密钥 bucketName: # oss的存储空间 policy: expire: 300 # 签名有效期(S) maxSize: 10 # 上传文件大小(M) callback: http://localhost:8080/aliyun/oss/callback # 文件上传成功后的回调地址 dir: prefix: mall/images/ # 上传文件夹路径前缀 阿里云上传成功后的回调函数 @Overridepublic OssCallbackResult callback(HttpServletRequest request) { OssCallbackResult result= new OssCallbackResult(); String filename = request.getParameter(\"filename\"); filename = \"http://\".concat(ALIYUN_OSS_BUCKET_NAME).concat(\".\").concat(ALIYUN_OSS_ENDPOINT).concat(\"/\").concat(filename); result.setFilename(filename); result.setSize(request.getParameter(\"size\")); result.setMimeType(request.getParameter(\"mimeType\")); result.setWidth(request.getParameter(\"width\")); result.setHeight(request.getParameter(\"height\")); return result;} 前端通过回调函数得到存储图片的url路径.","permalink":"https://shitianshuai1111.github.io/2017/03/31/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E7%AD%96%E7%95%A5/","photos":[]}],"categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://shitianshuai1111.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"命令行","slug":"命令行","permalink":"https://shitianshuai1111.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"干货","slug":"干货","permalink":"https://shitianshuai1111.github.io/tags/%E5%B9%B2%E8%B4%A7/"},{"name":"业务","slug":"业务","permalink":"https://shitianshuai1111.github.io/tags/%E4%B8%9A%E5%8A%A1/"}]}